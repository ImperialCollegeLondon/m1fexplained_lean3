import tactic
import combinatorics.pigeonhole
import data.int.parity
import data.nat.factorization.basic


lemma nat.ord_compl_eq_dvd {a b : ℕ} (h : ord_compl[2] a = ord_compl[2] b) (ha : 0 < a) (hab : a < b) :
  a ∣ b :=
begin
  -- if a = 2^k1 * p, b = 2^k2 * p
  set k1 : ℕ := a.factorization 2,
  set k2 : ℕ := b.factorization 2,
  rw dvd_iff_exists_eq_mul_left,
  -- c = 2^ (k2 - k1)
  use (2 ^ (k2 - k1)),
  have h02 : 0 < 2 := by norm_num,
  -- because of natural division is involved, we need divisibility
  have had := nat.ord_proj_dvd a 2,
  have hbd := nat.ord_proj_dvd b 2,
  have haf := pow_pos h02 k1,
  have hbf := pow_pos h02 k2,
  have hab : k1 ≤ k2,
  { by_contra hc,
    push_neg at hc,
    have hc' : 2 ^ k2 < 2 ^ k1,
    { rwa pow_lt_pow_iff,
      norm_num, },
    have hak : 0 < a / 2 ^ k1 := nat.div_pos (nat.ord_proj_le _ ha.ne') haf,
    suffices : b < a,
    { linarith, },
    have hc'' :  2 ^ k2 * (b / 2 ^ k2) < 2 ^ k1 * (a / 2 ^ k1),
    { rw ← h, apply mul_lt_mul_of_pos_right hc' hak, },
    rw mul_comm (2 ^ k2) (b / 2 ^ k2) at hc'',
    rw nat.div_mul_cancel at hc'',
    swap, exact hbd,
    rw mul_comm (2 ^ k1) (a / 2 ^ k1) at hc'',
    rwa nat.div_mul_cancel had at hc'', },
  rw ← nat.pow_div hab h02,
  -- again we need divisibility to proceed
  have hkd := pow_dvd_pow 2 hab,
  rw [mul_comm, ← nat.mul_div_assoc _ hkd, mul_comm a (2^k2), nat.mul_div_assoc _ had,
    h, mul_comm, nat.div_mul_cancel hbd],
end

lemma partf (T : finset ℕ) (hT : ∀ t ∈ T, (1 : ℤ) ≤ t ∧ t ≤ 200) (hTcard : T.card = 101) : ∃ a b : ℕ,
  a ∈ T ∧ b ∈ T ∧ a ≠ b ∧ a ∣ b :=
begin
  -- claim : every t can be written as 2^k * q for which q is odd, using ord_compl[2] t
  let Q : finset ℕ := (finset.Icc 1 200).filter odd,
  have hQcard : Q.card = 100,
  { -- Show that it equals (finset.Iio 100).map \<\la n, 2 * n + 1, proof_of_injectivity_here\> 
    have hQ : Q = (finset.Iio 100).map ⟨λ n, 2 * n + 1 , 
                                        begin intros a b hab, 
                                        simpa [add_left_inj, mul_eq_mul_left_iff, bit0_eq_zero, nat.one_ne_zero, or_false] using hab, 
                                        end ⟩,
    { dsimp [Q],
      rw le_antisymm_iff,
      split,
      { intros x hx,
        simp only [finset.mem_map, finset.mem_Iio, function.embedding.coe_fn_mk, exists_prop, nat.one_le_cast, finset.mem_filter,
          finset.mem_Icc, nat.odd_iff_not_even] at hx ⊢,
        refine ⟨((x-1)/2), _, _⟩,
        { rcases hx with ⟨⟨h1, h2⟩, h3⟩,
          zify at h2 ⊢,
          rw int.div_lt_iff_lt_mul,
          linarith,
          norm_num, },
        { rcases hx with ⟨⟨h1, h2⟩, h3⟩,
          rw ← nat.odd_iff_not_even at h3,
          cases h3 with k h3,
          rw h3,
          simp only [nat.add_succ_sub_one, add_zero, nat.mul_div_right, nat.succ_pos'], },
      },
      { intros x hx,
        simp only [finset.mem_map, finset.mem_Iio, function.embedding.coe_fn_mk, exists_prop, nat.one_le_cast, finset.mem_filter,
          finset.mem_Icc, nat.odd_iff_not_even] at hx ⊢,
        rcases hx with ⟨a, ⟨h1, h2⟩⟩,
        refine ⟨⟨_, _⟩, _⟩,
        { rw ← h2,
          linarith, },
        { rw ← h2,
          linarith, },
        { intro h,
          rw nat.even_iff at h,
          rw ← h2 at h,
          rw nat.mul_comm at h,
          rw nat.mul_add_mod a 2 1 at h,
          simp only [nat.one_mod, nat.one_ne_zero] at h,
          exact h, }, 
      },
    },
    rw hQ,
    simp only [nat.card_Iio, finset.card_map],
  },
  have hTO : Q.card * 1 < T.card,
  { rw [hQcard, hTcard], norm_num, },
  -- find a map from T to Q, by considering corresponding 'q'
  let f : ℕ → ℕ := λ z, ord_compl[2] z,
  have hf : ∀ t ∈ T, (f t) ∈ Q,
  { intros t ht,
    simp only [f, finset.mem_filter, finset.mem_Icc, nat.odd_iff_not_even],
    have ht0 : t ≠ 0,
    { specialize hT t ht, 
    cases hT with hT1 hT2, 
    linarith, }, 
    refine ⟨⟨_,_⟩,_⟩,
    { rw nat.one_le_div_iff,
      {apply nat.ord_proj_le 2 ht0, },
      {exact nat.ord_proj_pos t 2, }, },
    { apply nat.div_le_of_le_mul,
      have h1 := nat.ord_proj_pos t 2,
      rw ← nat.succ_le_iff at h1,
      exact le_mul_of_one_le_of_le h1 (hT t ht).2, },
    { simp only [even_iff_two_dvd, nat.not_dvd_ord_compl nat.prime_two ht0, not_false_iff], },
  },
  have := finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to hf hTO,
  dsimp at this,
  rcases this with ⟨y, hy1, hy2⟩,
  rw finset.one_lt_card at hy2,
  rcases hy2 with ⟨a, ha, b, hb, hab⟩,
  by_cases a < b,
  { refine ⟨a, b, _⟩,
    simp only [hab, ne.def, not_false_iff, true_and],
    rw finset.mem_filter at ha hb,
    simp only [ha.1, hb.1, true_and],
    have ha0 : 0 < a,
    { specialize hT a ha.1,
      cases hT with h1 h2,
      linarith, },
    suffices : f a = f b,
    { apply nat.ord_compl_eq_dvd, 
      exact this,
      exact ha0,
      exact h, },
    { rw [ha.2, hb.2], }, },
  { have h : b < a,
    { omega, },
    refine ⟨b, a, _⟩,
    simp only [ne.symm hab, ne.def, not_false_iff, true_and],
    rw finset.mem_filter at ha hb,
    simp only [ha.1, hb.1, true_and],
    have hb0 : 0 < b,
    { specialize hT b hb.1,
      cases hT with h1 h2,
      linarith, },
    suffices : f b = f a,
    { apply nat.ord_compl_eq_dvd, 
      exact this,
      exact hb0,
      exact h, },
    { rw [ha.2, hb.2], }, 
  },
end

